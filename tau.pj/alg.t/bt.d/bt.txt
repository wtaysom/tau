
Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
Distributed under the terms of the GNU General Public License v2



Ideas and comments on B-tree design

How the code be orginized.
Problems - because of splits, joins, grow, shrink and rebalance, parent, child
and sibling can change radically. Transaction system will need info about what
is changing.

Idea 1:
struct {
	Buf_s	*p;
	Buf_s	*c;
	Buf_s	*s;
	Lump_s	key;
	Lump_s	val;
	int	offset;
};

Terminology:
	lump - a pointer with a size. Nil is <0, NULL>. Notice that
		lumps are passed by value which means the size and
		the pointer are copied onto the stack.
	key - a lump. Index for a record.
	val - a lump. Value of a record.
	rec - <key, val>
	twig - <key, block>
	leaf - where the records of a the B-tree are stored.
	branch - Store indexes to to leaves on other branches

Todo
 1. Combine lf_audit and leaf_audit
 2. Timer loop to measure rates
 3. Measure hit rate in cache
 4. Plot results
 5. Log
 6. Transactions
 7. Dependency graph
 8. Global statistics - buffers
 9. Join
*10. Rebalance
 11. Prefix optimization
 12. Optimistic concurrency control - this is for the read path, if
 	the version changes while reading, restart. But this may be
 	dangerous if a record is updated.
 13. Multiple test threads
 14. Need iterator that returns key and val, I think that is what map does.
 15. Only dirty buffers when needed.
 16. Only flush dirty buffers when needed.
 17. pr_index -> pr_twig


void pr_rec (Rec_s rec)
	pr_lump(rec.key);
	pr_lump(rec.val);

void init_node(Buf_s *node, Btree_s *t, u8 kind)
	init_head(node->d, kind, node->block);

void rec_dump (Rec_s rec)
	lump_dump(rec.key);
	lump_dump(rec.val);

void lf_dump(Buf_s *node, int indent)
	if (Dump_buf) pr_buf(node, indent);
	pr_head(head, indent);
	foreach rec
		rec = get_rec(head, i);
		rec_dump(rec);
	if (head->is_split) node_dump(node->user, head->last, indent);

void br_dump(Buf_s *node, int indent)
	pr_head(head, indent);
	foreach twig
		twig = get_twig(head, i);
		lump_dump(twig.key);
		printf(" = %lld\n", twig.block);
		node_dump(node->user, twig.block, indent + 1);
	if (head->is_split) node_dump(node->user, head->last, indent);
	else node_dump(node->user, head->last, indent + 1);

void node_dump(Btree_s *t, u64 block, int indent)
	if (!block) return;
	node = buf_get(t->cache, block);
	head = node->d;
	LEAF-> lf_dump(node, indent);
	BRANCH-> br_dump(node, indent + 1);
	buf_put(node);

bool isLE(Head_s *head, Lump_s key, unint i)
	target = get_key(head, i);
	return cmplump(key, target) <= 0;	

int isEQ(Head_s *head, Lump_s key, unint i)
	target = get_key(head, i);
	return cmplump(key, target);	

void _store_rec(Head_s *head, Lump_s key, Lump_s val, unint i)
	store_lump(head, val);
	store_lump(head, key);
	store_end(head, i);

void rec_copy(Head_s *dst, int a, Head_s *src, int b)
	rec = get_rec(src, b);
	store_lump(dst, rec.val);
	store_lump(dst, rec.key);
	store_end(dst, a);

void twig_copy(Head_s *dst, int a, Head_s *src, int b)
	twig = get_twig(src, b);
	store_block(dst, twig.block);
	store_lump(dst, twig.key);
	store_end(dst, a);

void lf_compact(Head_s *leaf)
	init_head(h, LEAF, leaf->block);
	foreach rec
		rec_copy(h, i, leaf, i);
	memmove(leaf, h, SZ_BUF);

void br_compact(Head_s *branch)
	init_head(h, BRANCH, branch->block);
	foreach twig
		twig_copy(h, i, branch, i);
	memmove(branch, h, SZ_BUF);

void store_rec(Head_s *head, Lump_s key, Lump_s val, unint i)
	lf_compact(head);
	store_lump(head, val);
	store_lump(head, key);
	store_end(head, i);

void store_twig(Head_s *head, Twig_s twig, unint i)
	br_compact(head);
	store_block(head, twig.block);
	store_lump(head, twig.key);
	store_end(head, i);

void delete_rec(Head_s *head, unint i)
	rec = get_rec(head, i);
	memmove(&head->rec[i], &head->rec[i+1],
		(head->num_recs - i) * SZ_U16);

void lf_audit(const char *fn, unsigned line, Head_s *head)
	foreach rec
		rec = get_rec(head, i);
		free -= rec.key.size + rec.val.size + 3 * SZ_U16;

void br_audit(const char *fn, unsigned line, Head_s *head)
	foreach twig
		key = get_key(head, i);
		free -= key.size + SZ_U64 + 2 * SZ_U16;

void lf_del_rec(Head_s *head, unint i)
	rec = get_rec(head, i);
	memmove(&head->rec[i], &head->rec[i+1],
			(head->num_recs - i) * SZ_U16);

void lf_rec_copy(Head_s *dst, int i, Head_s *src, int j)
	rec = get_rec(src, j);
	store_rec(dst, rec.key, rec.val, i);	

void lf_rec_move(Head_s *dst, int i, Head_s *src, int j)
	rec = get_rec(src, j);
	store_rec(dst, rec.key, rec.val, i);
	lf_del_rec(src, j);

void br_del_rec(Head_s *head, unint i)
	key = get_key(head, i);
	memmove(&head->rec[i], &head->rec[i+1],
			(head->num_recs - i) * SZ_U16);

void br_rec_copy(Head_s *dst, int i, Head_s *src, int j)
	twig = get_twig(src, j);
	store_twig(dst, twig, i);

void br_rec_move(Head_s *dst, int i, Head_s *src, int j)
	twig = get_twig(src, j);
	store_twig(dst, twig, i);
	br_del_rec(src, j);

Buf_s *node_new(Btree_s *t, u8 kind)
	node = buf_new(t->cache);
	init_node(node, t, kind);

Buf_s *br_new(Btree_s *t)
	node_new(t, BRANCH);

Buf_s *lf_new(Btree_s *t)
	node_new(t, LEAF);

Buf_s *lf_split(Buf_s *bchild)
	Buf_s	*bsibling = lf_new(t);
	for half recs
		lf_rec_move(sibling, i, child, middle);

int lf_insert(Buf_s *bleaf, Lump_s key, Lump_s val)
	while (size > leaf->free)
		right = lf_split(bleaf);
		if (isLE(right->d, key, 0)) buf_put(right);
		else  buf_put(bleaf);
	lf_compact(leaf);
	i = find_le(leaf, key);
	store_rec(leaf, key, val, i);
	buf_put(bleaf);

Buf_s *grow(Buf_s *bchild)
	bparent = br_new(t);
	twig.key = get_key(child, child->num_recs - 1);
	store_twig(parent, twig, 0);
	if (child->kind == LEAF) 
		child->last = 0;
	else
		child->last = get_block(child, child->num_recs - 1);
		br_del_rec(child, child->num_recs - 1);	

Buf_s *br_split(Buf_s *bchild)
	Buf_s	*bsibling = br_new(t);
	for half twigs
		br_rec_move(sibling, i, child, middle);

Buf_s *br_reinsert(Buf_s *bparent, Buf_s *bchild, int x)
	twig.key = get_key(child, child->num_recs - 1);
	while (size > parent->free) {
		Buf_s	*right = br_split(bparent);
		if (isLE(parent, twig.key, parent->num_recs - 1))
			buf_put(right);
		else
			buf_put(bparent);
		x = find_le(parent, twig.key);
	br_compact(parent);
	store_twig(parent, twig, x);

Buf_s *br_store(Buf_s *bparent, Buf_s *bchild, int x)
	if (child->num_recs == 0) /* We have a degenerate case */
		update_block(parent, child->last, x);
		buf_free(bchild);
		return bparent;
	twig.key = get_key(child, child->num_recs - 1);
	while (size > parent->free) 
		Buf_s	*right = br_split(bparent);
		if (isLE(parent, twig.key, parent->num_recs - 1)) buf_put(right);
		else buf_put(bparent);
		x = find_le(parent, twig.key);
	br_compact(parent);
	if (x == parent->num_recs)
		twig.block = parent->last;
		parent->last = child->last;
	else
		update_block(parent, child->last, x);
		twig.block = child->block;
	store_twig(parent, twig, x);
	if (child->kind == BRANCH) {
		child->last = get_block(child, child->num_recs - 1);
		br_del_rec(child, child->num_recs - 1);	

int br_insert(Buf_s *bparent, Lump_s key, Lump_s val)
	for(;;)
		x = find_le(parent, key);
		if (x == parent->num_recs) block = parent->last;
		else block = get_block(parent, x);
		bchild = buf_get(bparent->cache, block);
		if (child->is_split) {
			bparent = br_store(bparent, bchild, x);
			buf_put(bchild);
			continue;
		if (child->kind == LEAF) {
			buf_put(bparent);
			lf_insert(bchild, key, val);
			return 0;
		buf_put(bparent);
		bparent = bchild;
		parent = bparent->d;

int t_insert(Btree_s *t, Lump_s key, Lump_s val)
	if (t->root) node = buf_get(t->cache, t->root);
	else
		node = lf_new(t);
		t->root = node->block;
	if (head->is_split) {
		Buf_s *new_node = grow(node);
		buf_put(node);
	if (head->kind == LEAF) lf_insert(node, key, val);
	else br_insert(node, key, val);

int lf_find(Buf_s *bleaf, Lump_s key, Lump_s *val)
	for (;;)
		i = find_eq(head, key);
		if (i == -1) {
			return BT_ERR_NOT_FOUND;
		}
		if (i == head->num_recs)
			if (head->is_split)
				right = buf_get(bleaf->cache, head->last);
				buf_put(bleaf);
			else
				return BT_ERR_NOT_FOUND;
		else
			v = get_val(head, i);
			*val = duplump(v);

int br_find(Buf_s *bparent, Lump_s key, Lump_s *val)
	for(;;)
		x = find_le(parent, key);
		if (x == parent->num_recs) block = parent->last;
		else block = get_block(parent, x);
		bchild = buf_get(bparent->cache, block);
		if (child->kind == LEAF) {
			buf_put(bparent);
			lf_find(bchild, key, val);
			return 0;
		}
		buf_put(bparent);

int t_find(Btree_s *t, Lump_s key, Lump_s *val)
	node = buf_get(t->cache, t->root);
	if (head->kind == LEAF) lf_find(node, key, val);
	else br_find(node, key, val);

int lf_delete(Buf_s *bleaf, Lump_s key)
	for (;;) {
		i = find_eq(head, key);
		if (i == head->num_recs)
			if (head->is_split)
				right = buf_get(bleaf->cache, head->last);
				buf_put(bleaf);
			else
				return BT_ERR_NOT_FOUND;
		else
			delete_rec(head, i);
			buf_put(bleaf);
			return 0;

Buf_s *join(Buf_s *bparent, int x, Buf_s *bchild, Buf_s *bsibling)
	if (child->kind == LEAF)
		lf_compact(sibling);
		foreach child rec
			lf_rec_move(sibling, i, child, 0);
	else
		br_compact(child);
		foreach child twig
		for (i = 0; child->num_recs; i++) {
			br_rec_move(sibling, i, child, 0);
	br_del_rec(parent, x);
	buf_free(bchild);
	buf_put(bsibling);

Buf_s *rebalance(Buf_s *bparent, int x, Buf_s *bchild)
	if (x == parent->num_recs)
		/* No right sibling */
		return bparent;
	if (y == parent->num_recs) block = parent->last;
	else block = get_block(parent, y);
	bsibling = buf_get(bparent->cache, block);
	/* Can we join? */
	if (child->free > inuse(sibling))
		return join(bparent, x, bchild, bsibling);
	if (sibling->num_recs == 0)
		//XXX: should delete it
		buf_put(bsibling);
		return bparent;
	if (child->kind == LEAF)
		lf_compact(child);
		for (i = 0; ;i++)
			lf_rec_move(child, child->num_recs, sibling, 0);
			if (child->free <= sibling->free) break;
	else
		br_compact(child);
		for (i = 0; ;i++) {
			//XXX: see comments above.
			br_rec_move(child, child->num_recs, sibling, 0);
			if (child->free <= sibling->free) break;
	buf_put(bsibling);
	buf_put(bchild);
	br_del_rec(parent, x);
	bparent = br_reinsert(bparent, bchild, x);

int br_delete(Buf_s *bparent, Lump_s key)
	for(;;) {
		x = find_le(parent, key);
		if (x == parent->num_recs) block = parent->last;
		else block = get_block(parent, x);
		bchild = buf_get(bparent->cache, block);
		if (child->is_split) {
			bparent = br_store(bparent, bchild, x);
			buf_put(bchild);
			continue;
		else if (child->free > REBALANCE)
			bparent = rebalance(bparent, x, bchild);
			continue;	// Had to add this for join
		}
		if (child->kind == LEAF)
			buf_put(bparent);
			lf_delete(bchild, key);
			return 0;
		buf_put(bparent);

int t_delete(Btree_s *t, Lump_s key)
	node = buf_get(t->cache, t->root);
	if (head->kind == LEAF) lf_delete(node, key);
	else br_delete(node, key);

Btree_s *t_new(char *file, int num_bufs)
	t = ezalloc(sizeof(*t));
	t->cache = cache_new(file, num_bufs, SZ_BUF);

void t_dump(Btree_s *t)
	node_dump(t, t->root, 0);

bool pr_key (Head_s *head, unint i)
	printf(" %4ld, %4ld:", x, size);
	pr_lump(lumpmk(size, start));

bool pr_val (Head_s *head, unint i)
	printf(" %4ld, %4ld:", x, size);
	pr_lump(lumpmk(size, start));

bool pr_record (Head_s *head, unint i)
	printf(" %4ld, %4ld:", x, size);
	pr_lump(lumpmk(size, start));
	printf(" : %4ld:", size);
	pr_lump(lumpmk(size, start));

void pr_leaf(Head_s *head)
	pr_head(head, 0);
	foreach rec
		pr_record(head, i);

bool pr_index (Head_s *head, unint i)
	printf(" %4ld, %4ld:", x, size);
	foreach char
		if (isprint(start[i])) printf("%c", start[i]);
		else putchar('.');
	UNPACK(start, block);
	printf(" : %lld", block);

void pr_branch(Head_s *head)
	pr_head(head, 0);
	foreach twig
		pr_index(head, i);

void pr_node(Head_s *head)
	if (head->kind == LEAF) pr_leaf(head);
	else pr_branch(head);

static void pr_all_leaves(Buf_s *node)
	foreach rec
		rec = get_rec(head, i);
		printf("%4ld. ", Recnum++);
		lump_dump(rec.key);
		lump_dump(rec.val);
	if (head->is_split) pr_all_nodes(node->user, head->last);

void pr_all_branches(Buf_s *node)
	foreach twig
		block = get_block(head, i);
		pr_all_nodes(node->user, block);
	pr_all_nodes(node->user, head->last);

void pr_all_nodes(Btree_s *t, u64 block)
	node = buf_get(t->cache, block);
	case LEAF: pr_all_leaves(node);
	case BRANCH: pr_all_branches(node);
	buf_put(node);

void pr_all_records(Btree_s *t)
	printf("=====All Records in Order=======\n");
	pr_all_nodes(t, t->root);

int lf_map(Buf_s *node, Apply_s apply)
	foreach rec
		rec = get_rec(head, i);
		rc = apply.func(rec, apply.user);
	if (head->is_split) node_map(node->user, head->last, apply);

int br_map(Buf_s *node, Apply_s apply)
	foreach twig
		block = get_block(head, i);
		rc = node_map(node->user, block, apply);
	node_map(node->user, head->last, apply);

int node_map(Btree_s *t, u64 block, Apply_s apply)
	node = buf_get(t->cache, block);
	case LEAF: lf_map(node, apply);
	case BRANCH: br_map(node, apply);
	buf_put(node);

int t_map(Btree_s *t, Apply_f func, void *user)
	node_map(t, t->root, mk_apply(func, user));

int rec_audit (Rec_s rec, void *user) {
	if (cmplump(rec.key, *old) < 0) {
		pr_lump(rec.key);
		printf(" < ");
		pr_lump(*old);
		printf("  ");
		fatal("keys out of order");
	freelump(*old);
	*old = duplump(rec.key);

int leaf_audit(Buf_s *node, Audit_s *audit)
	audit->records += head->num_recs;
	if (head->is_split) node_audit(node->user, head->last, audit);

int branch_audit(Buf_s *node, Audit_s *audit)
	foreach twig
		block = get_block(head, i);
		rc = node_audit(node->user, block, audit);
	return node_audit(node->user, head->last, audit);

int node_audit(Btree_s *t, u64 block, Audit_s *audit)
	node = buf_get(t->cache, block);
	case LEAF: leaf_audit(node, audit);
	case BRANCH: branch_audit(node, audit);
	buf_put(node);

int t_audit (Btree_s *t) {
	int rc = t_map(t, rec_audit, &old);
	rc = node_audit(t, t->root, &audit);
